# This code has been written by Otto Oikarinen.
# Some parts have been generated by CoPilot. I'll mark those parts specifically.

# Imports
import os
import sqlite3
import pymongo
import json

# Global variables
SQL_DATABASE_FILE = "SQL_database.db"
SQL_CREATION_FILE = "create_SQL_DB.sql"
DB_NAME="DIS_database"
SEED_FILE="mongo_seed.json"
URI="mongodb://localhost:27017/"
HIGHEST_ID = 100

# Data tables
ALL_TABLES = ["library", "user", "book", "movie", "cd", "sheet music", "comics"]
SQL_TABLES = ["library", "user", "book", "movie", "cd"]
NOSQL_TABLES = ["library", "user", "book", "sheet music", "comics"]

# Main function to call all other functions.
def main():
    sql_connection = createSQLDatabase() # First create databases or restore them to original state.
    mongo_client, mongo_db = createNoSQLDatabase()

    while True:
        
        print("What do you want to do?")
        print("1) Read from database")
        print("2) Update database")
        print("3) Delete from database")
        print("4) Insert into database")
        print("5) Restore databases to original state")
        print("0) Exit")
        choice = input("Enter the number of your choice: ")
        if choice == '1':
            print("Reading from database.")
            readDatabase(sql_connection, mongo_db, chosen_table=None)  
        elif choice == '2':
            print("Updating database.")
            updateDatabase(sql_connection, mongo_db)
        elif choice == '3':
            print("Deleting from database")
            deleteFromDatabase(sql_connection, mongo_db)
        elif choice == '4':
            print("Inserting into database.")
            insertIntoDatabase(sql_connection, mongo_db)
        elif choice == '5':
            print("Restoring databases to original state.")
            restoreDatabases(mongo_client)
        elif choice == '0':
            print("Exiting program.")
            exit()
        else:
            print("Invalid choice. Please try again.")

    return 0

# Read choices
def readChoices():
    print("Choose table.")
    # Create menu automatically from ALL_TABLES
    for i, table in enumerate(ALL_TABLES, start=1):
        print(f"{i}) {table}")
    print("0) Go back")
    choice = input("Enter the number of your choice: ")

    # If 0, we go back to main menu
    if choice == '0':
        return 0
    
    # Validate choice and handle errors.
    try:
        choice = int(choice)
        if 1 <= choice <= len(ALL_TABLES):
            return ALL_TABLES[choice - 1]
        else:
            print("Invalid choice. Please try again.")
            return readChoices()
    except ValueError:
        print("Invalid input. Please enter a number.")
        return readChoices()

# Read sqlite-database
def readDatabase(sql_connection, mongo_db, chosen_table):
    if chosen_table is None:
        chosen_table = readChoices()
    if chosen_table == 0:
        return
    if chosen_table in SQL_TABLES:
        readSQLiteDatabase(sql_connection, chosen_table)
    if chosen_table in NOSQL_TABLES:
        readMongoDatabase(mongo_db, chosen_table)
    if chosen_table not in SQL_TABLES and chosen_table not in NOSQL_TABLES:
        print(f"Table/collection '{chosen_table}' not found in either database.")

    return 0

def readSQLiteDatabase(sql_connection, chosen_table):
    cursor = sql_connection.cursor()
    try:
        print(f"Reading from SQLite table '{chosen_table}':")
        cursor.execute(f"SELECT * FROM {chosen_table}")
        rows = cursor.fetchall()
            
        for row in rows:
            print(f"{row[0]}, {row[1]}, {row[2]}")
    except sqlite3.Error as e:
        print(f"Error reading from SQLite table '{chosen_table}': {e}")
    return 0

# Read MongoDB-database
def readMongoDatabase(mongo_db, chosen_table):
    try:
        print(f"Reading from MongoDB collection '{chosen_table}':")
        collection = mongo_db[chosen_table]
        documents = collection.find()
        for doc in documents:
            # Following snippet coded by CoPilot.
            # Preserve insertion order, ignore MongoDB internal _id
            values = [v for k, v in doc.items() if k != "_id"]
            # Ensure at least three columns to match "id, name, location" style
            while len(values) < 3:
                values.append("")
            # Convert values to strings for consistent printing
            a, b, c = map(lambda x: "" if x is None else str(x), values[:3])
            print(f"{a}, {b}, {c}")

    except pymongo.errors.PyMongoError as e:
        print(f"Error reading from MongoDB collection '{chosen_table}': {e}")
    return 0

# Insert into database
def insertIntoDatabase(sql_connection, mongo_db):
    chosen_table = readChoices()
    if chosen_table is None:
        return

    # Gather data to insert
    id, first_insert, second_insert = gatherInsertData(chosen_table)

    if chosen_table in SQL_TABLES:
        insertIntoSQLiteDatabase(sql_connection, chosen_table, id, first_insert, second_insert)
    elif chosen_table in NOSQL_TABLES:
        insertIntoMongoDB(mongo_db, chosen_table, id, first_insert, second_insert)
    else:
        print(f"Table/collection '{chosen_table}' not found in either database.")

    return 0

# Gather data based on table
def gatherInsertData(chosen_table):
    global HIGHEST_ID
    HIGHEST_ID += 1
    id = HIGHEST_ID

    if chosen_table == "library":
        first_insert_string = "Enter library name: "
        second_insert_string = "Enter library location: "
    elif chosen_table == "user":
        first_insert_string = "Enter user name: "
        second_insert_string = "Enter user email: "
    elif chosen_table == "book":
        first_insert_string = "Enter book title: "
        second_insert_string = "Enter book author: "
    elif chosen_table == "movie":
        first_insert_string = "Enter movie title: "
        second_insert_string = "Enter movie director: "
    elif chosen_table == "cd":
        first_insert_string = "Enter CD title: "
        second_insert_string = "Enter CD artist: "
    elif chosen_table == "sheet music":
        first_insert_string = "Enter sheet music title: "
        second_insert_string = "Enter sheet music composer: "
    elif chosen_table == "comics":
        first_insert_string = "Enter comic title: "
        second_insert_string = "Enter comic illustrator: "

    first_insert = input(first_insert_string)
    second_insert = input(second_insert_string)

    return id, first_insert, second_insert

def getColumns(chosen_table):
    if chosen_table == "library":
        return "name", "location"
    elif chosen_table == "user":
        return "name", "email"
    elif chosen_table == "book":
        return "title", "author"
    elif chosen_table == "movie":
        return "title", "director"
    elif chosen_table == "cd":
        return "title", "artist"
    elif chosen_table == "sheet music":
        return "title", "composer"
    elif chosen_table == "comics":
        return "title", "illustrator"

# Insert sqlite
def insertIntoSQLiteDatabase(sql_connection, chosen_table, id, first_insert, second_insert):
    cursor = sql_connection.cursor()

    column1, column2 = getColumns(chosen_table)

    try:
        cursor.execute(f"INSERT INTO {chosen_table} (id, {column1}, {column2}) VALUES (?, ?, ?)", (id, first_insert, second_insert))
        sql_connection.commit()
        print(f"Inserted into SQLite table '{chosen_table}': {id}, {first_insert}, {second_insert}")
    except sqlite3.Error as e:
        print(f"Error inserting into SQLite table '{chosen_table}': {e}")
    return 0

# Insert MongoDB
def insertIntoMongoDB(mongo_db, chosen_table, id, first_insert, second_insert):
    if chosen_table == "sheet music":
        document = {"id": id, "title": first_insert, "composer": second_insert}
    elif chosen_table == "comics":
        document = {"id": id, "title": first_insert, "illustrator": second_insert}
    #Insert document into collection
    try:
        collection = mongo_db[chosen_table]
        collection.insert_one(document)
        print(f"Inserted into MongoDB collection '{chosen_table}': {document}")
    except pymongo.errors.PyMongoError as e:
        print(f"Error inserting into MongoDB collection '{chosen_table}': {e}")
    return 0

# Update from databases
def updateDatabase(sql_connection, mongo_db):
    chosen_table = readChoices()
    if chosen_table is None:
        return
    readDatabase(sql_connection, mongo_db, chosen_table)
    id_to_update = input("Enter the ID of the record to update: ")
    new_first_value = input("Enter the new value for the first field: ")
    new_second_value = input("Enter the new value for the second field: ")

    if chosen_table in SQL_TABLES:
        updateSQLiteDatabase(sql_connection, chosen_table, id_to_update, new_first_value, new_second_value)
    if chosen_table in NOSQL_TABLES:
        updateMongoDB(mongo_db, chosen_table, id_to_update, new_first_value, new_second_value)
    if chosen_table not in SQL_TABLES and chosen_table not in NOSQL_TABLES:
        print(f"Table/collection '{chosen_table}' not found in either database.")

    return 0

# Update sqlite
def updateSQLiteDatabase(sql_connection, chosen_table, id_to_update, new_first_value, new_second_value):
    cursor = sql_connection.cursor()
    column1, column2 = getColumns(chosen_table)
    try:
        cursor.execute(f"UPDATE {chosen_table} SET {column1} = ?, {column2} = ? WHERE id = ?", (new_first_value, new_second_value, id_to_update))
        sql_connection.commit()
        if cursor.rowcount > 0:
            print(f"Updated record with ID {id_to_update} in SQLite table '{chosen_table}'.")
        else:
            print(f"No record with ID {id_to_update} found in SQLite table '{chosen_table}'.")
    except sqlite3.Error as e:
        print(f"Error updating SQLite table '{chosen_table}': {e}")
    return 0

# Update MongoDB
def updateMongoDB(mongo_db, chosen_table, id_to_update, new_first_value, new_second_value):
    try:
        collection = mongo_db[chosen_table]
        column1, column2 = getColumns(chosen_table)
        result = collection.update_one({"id": int(id_to_update)}, {"$set": {column1: new_first_value, column2: new_second_value}})
        if result.matched_count > 0:
            print(f"Updated record with ID {id_to_update} in MongoDB collection '{chosen_table}'.")
        else:
            print(f"No record with ID {id_to_update} found in MongoDB collection '{chosen_table}'.")
    except pymongo.errors.PyMongoError as e:
        print(f"Error updating MongoDB collection '{chosen_table}': {e}")
    return 0

# Delete from databases
def deleteFromDatabase(sql_connection, mongo_db):
    chosen_table = readChoices()
    if chosen_table is None:
        return
    readDatabase(sql_connection, mongo_db, chosen_table)
    id_to_delete = input("Enter the ID of the record to delete: ")

    if chosen_table in SQL_TABLES:
        deleteFromSQLiteDatabase(sql_connection, chosen_table, id_to_delete)
    if chosen_table in NOSQL_TABLES:
        deleteFromMongoDB(mongo_db, chosen_table, id_to_delete)
    if chosen_table not in SQL_TABLES and chosen_table not in NOSQL_TABLES:
        print(f"Table/collection '{chosen_table}' not found in either database.")

    return 0

# Delete from sqlite
# Generated by CoPilot.
def deleteFromSQLiteDatabase(sql_connection, chosen_table, id_to_delete):
    cursor = sql_connection.cursor()
    try:
        cursor.execute(f"DELETE FROM {chosen_table} WHERE id = ?", (id_to_delete,))
        sql_connection.commit()
        if cursor.rowcount > 0:
            print(f"Deleted record with ID {id_to_delete} from SQLite table '{chosen_table}'.")
        else:
            print(f"No record with ID {id_to_delete} found in SQLite table '{chosen_table}'.")
    except sqlite3.Error as e:
        print(f"Error deleting from SQLite table '{chosen_table}': {e}")
    return 0

# Delete from MongoDB
# Generated by CoPilot.
def deleteFromMongoDB(mongo_db, chosen_table, id_to_delete):
    try:
        collection = mongo_db[chosen_table]
        result = collection.delete_one({"id": int(id_to_delete)})
        if result.deleted_count > 0:
            print(f"Deleted record with ID {id_to_delete} from MongoDB collection '{chosen_table}'.")
        else:
            print(f"No record with ID {id_to_delete} found in MongoDB collection '{chosen_table}'.")
    except pymongo.errors.PyMongoError as e:
        print(f"Error deleting from MongoDB collection '{chosen_table}': {e}")
    return 0

# Create databases if they don't already exist.
def createSQLDatabase():
    
    if not os.path.exists(SQL_CREATION_FILE):
        print(f"Schema file for SQL-database does not exist. Cannot create database.")
        exit()
    
    try: 
        print("Connecting to SQLite database...")
        if not os.path.exists(SQL_DATABASE_FILE):
            with open(SQL_CREATION_FILE, 'r', encoding='utf-8') as file:
                schema_sql = file.read()

            conn = sqlite3.connect(SQL_DATABASE_FILE)
            cursor = conn.cursor()
            cursor.executescript(schema_sql)
            conn.commit()
            print(f"Created database {SQL_DATABASE_FILE} successfully.")
        else:
            print(f'{SQL_DATABASE_FILE} already exists.')
            conn = sqlite3.connect(SQL_DATABASE_FILE)

    except Exception as e:
        print(f"Error creating database {SQL_DATABASE_FILE}: {e}")
        print("Closing application.")
        exit()

    print("Connected to SQLite database successfully.")
    return conn

def createNoSQLDatabase():
    print("Connecting to MongoDB database...")
    try:
        client = pymongo.MongoClient(URI, serverSelectionTimeoutMS=5000)
        # verify connection
        client.admin.command("ping")
    except pymongo.errors.PyMongoError as e:
        print(f"Could not connect to MongoDB at {URI}: {e}")
        return None, None

    mongo_db = client[DB_NAME]

    # Ensure all expected NoSQL collections exist (use NOSQL_TABLES so we don't miss any)
    existing = mongo_db.list_collection_names()
    for collection in NOSQL_TABLES:
        if collection not in existing:
            try:
                mongo_db.create_collection(collection)
            except pymongo.errors.CollectionInvalid:
                pass

    populate_mongo_from_seed(SEED_FILE, client, DB_NAME)
    print("Connected to MongoDB database successfully.")
    return client, mongo_db

# Restore databases to their original state
def restoreDatabases(mongo_client):
    
    try:
        if os.path.exists(SQL_DATABASE_FILE):
            os.remove(SQL_DATABASE_FILE)
            print(f"Deleted database {SQL_DATABASE_FILE} successfully.")
            createSQLDatabase()
    except Exception:
        print(f"Error deleting database {SQL_DATABASE_FILE}.")
    
    try:
        mongo_client.drop_database(DB_NAME)
        populate_mongo_from_seed(SEED_FILE, mongo_client, DB_NAME)
        print(f"Restored database {DB_NAME} successfully.")
    except Exception as e:
        print(f"Could not restore database {DB_NAME}: {e}")

    return 0

# This function has been generated by CoPilot.
def populate_mongo_from_seed(seed_path, mongo_client, DB_NAME="DIS_database"):
    """
    Read JSON seed file and populate MongoDB collections.
    Drops each target collection before inserting to avoid duplicates.
    """
    try:
        with open(seed_path, "r", encoding="utf-8") as f:
            seed = json.load(f)
    except Exception as e:
        print(f"Cannot read seed file {seed_path}: {e}")
        return False

    db = mongo_client[DB_NAME]
    for coll_name, docs in seed.items():
        try:
            db.drop_collection(coll_name)
        except Exception:
            pass
        if docs:
            try:
                # insert_many expects dicts; keep ids as-is
                db[coll_name].insert_many(docs)
            except Exception as e:
                print(f"Error inserting into {coll_name}: {e}")
                return False
    return True

if __name__ == "__main__":
    main()
