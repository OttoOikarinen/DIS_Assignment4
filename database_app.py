# This code has been written by Otto Oikarinen.
# Some parts have been generated by CoPilot. I'll mark those parts specifically.

# Imports
import os
import sqlite3
import pymongo
import json

# Global variables
SQL_DATABASE_FILE = "SQL_database.db"
SQL_CREATION_FILE = "create_SQL_DB.sql"
DB_NAME="DIS_database"
SEED_FILE="mongo_seed.json"
URI="mongodb://localhost:27017/"
HIGHEST_ID = 100    # In real application, we would query the databases to find the highest ID.

# Data tables to keep track what is where.
ALL_TABLES = ["library", "user", "book", "movie", "cd", "sheet music", "comics"]
SQL_TABLES = ["library", "user", "book", "movie", "cd"]
NOSQL_TABLES = ["library", "user", "book", "sheet music", "comics"]

# Colored print function for logging. Generated by ChatGPT.
def cprint(text, color): 
    colors = {
        "green": "\033[92m",
        "red": "\033[91m",
        "yellow": "\033[93m"
    }
    print(colors[color] + text + "\033[0m")

# Main function to call all other functions.
def main():
    # First create and connect to databases.
    sql_connection = createSQLDatabase() 
    mongo_client, mongo_db = createNoSQLDatabase()

    # Endless loop for user to make choices.
    while True:
        print("What do you want to do?")
        print("1) Read from database")
        print("2) Update database")
        print("3) Delete from database")
        print("4) Insert into database")
        print("0) Exit")
        cprint("NOTE: To restore databases to original state, choose option 0 and restart application.", "yellow")
        choice = input("Enter the number of your choice: ")
        if choice == '1':
            print("Reading from database.\n")
            readDatabase(sql_connection, mongo_db, chosen_table=None) 
        elif choice == '2':
            print("Updating database.\n")
            updateDatabase(sql_connection, mongo_db)
        elif choice == '3':
            print("Deleting from database\n")
            deleteFromDatabase(sql_connection, mongo_db)
        elif choice == '4':
            print("Inserting into database.\n")
            insertIntoDatabase(sql_connection, mongo_db)
        #elif choice == '5':
        #    print("Restoring databases to original state.\n")
        #    restoreDatabases(mongo_client)
        elif choice == '0':
            print("Exiting program.")
            exit()
        else:
            cprint("Invalid choice. Please try again.\n", "red")

        print()

# Read choices
def readChoices():
    print("Choose table:")

    # Create menu automatically from ALL_TABLES
    for i, table in enumerate(ALL_TABLES, start=1):
        print(f"{i}) {table}")
    print("0) Go back\n")
    choice = input("Enter the number of your choice: ")

    # If 0, we go back to main menu
    if choice == '0':
        return 0
    
    # Validate choice and handle errors.
    try:
        choice = int(choice)
        if 1 <= choice <= len(ALL_TABLES):
            return ALL_TABLES[choice - 1]
        else:
            cprint("Invalid choice. Please try again.\n", "red")
            return readChoices() # Recursive call for invalid input
    except ValueError:
        cprint("Invalid input. Please enter a number.\n", "red")
        return readChoices() # Recursive call for invalid input

# Read sqlite-database
def readDatabase(sql_connection, mongo_db, chosen_table):
    # In case no table has been chosen yet, ask user to choose one.
    if chosen_table is None:
        chosen_table = readChoices()
    # If user chose to go back, return to main menu.
    if chosen_table == 0:
        return
    
    # Read from the chosen database(s). Try both if table exists in both.
    if chosen_table in SQL_TABLES:
        readSQLiteDatabase(sql_connection, chosen_table)
    if chosen_table in NOSQL_TABLES:
        readMongoDatabase(mongo_db, chosen_table)
    if chosen_table not in SQL_TABLES and chosen_table not in NOSQL_TABLES: # Should never get here.
        cprint(f"Table/collection '{chosen_table}' not found in either database.\n", "red")

    return 0

# Read table from sqlite
def readSQLiteDatabase(sql_connection, chosen_table):
    cursor = sql_connection.cursor()
    try:
        cursor.execute(f"SELECT * FROM {chosen_table}")
        rows = cursor.fetchall() # Fetch all rows from the table
            
        for row in rows:    # Print each row
            print(f"{row[0]}, {row[1]}, {row[2]}") 
    except sqlite3.Error as e:
        cprint(f"Error reading from SQLite table '{chosen_table}': {e}\n", "red")
    return 0

# Read MongoDB-database
def readMongoDatabase(mongo_db, chosen_table):
    try:
        
        collection = mongo_db[chosen_table]
        documents = collection.find()
        for doc in documents:
            # Following snippet coded by CoPilot.
            # Preserve insertion order, ignore MongoDB internal _id
            values = [v for k, v in doc.items() if k != "_id"]
            # Ensure at least three columns to match "id, name, location" style
            while len(values) < 3:
                values.append("")
            # Convert values to strings for consistent printing
            a, b, c = map(lambda x: "" if x is None else str(x), values[:3])
            print(f"{a}, {b}, {c}")

    except pymongo.errors.PyMongoError as e:
        cprint(f"Error reading from MongoDB collection '{chosen_table}': {e}", "red")
    return 0

# Insert into database
def insertIntoDatabase(sql_connection, mongo_db):
    chosen_table = readChoices() # Choose table to insert into
    if chosen_table is None:
        return

    # Gather data to insert
    id, first_insert, second_insert = gatherInsertData(chosen_table)   # In its own function for clarity.

    if chosen_table in SQL_TABLES: # I decided to always use sqlite if table exists in both. Therefore if-elif is used.
        insertIntoSQLiteDatabase(sql_connection, chosen_table, id, first_insert, second_insert)
    elif chosen_table in NOSQL_TABLES:
        insertIntoMongoDB(mongo_db, chosen_table, id, first_insert, second_insert)
    else: # Should never get here.
        cprint(f"Table/collection '{chosen_table}' not found in either database.\n", "red")

    return 0

# Gather data based on table
def gatherInsertData(chosen_table):
    # Get the highest ID and add 1 for new entry.
    global HIGHEST_ID 
    HIGHEST_ID += 1
    id = HIGHEST_ID

    # Prompt strings based on table
    if chosen_table == "library":
        first_insert_string = "Enter library name: "
        second_insert_string = "Enter library location: "
    elif chosen_table == "user":
        first_insert_string = "Enter user name: "
        second_insert_string = "Enter user email: "
    elif chosen_table == "book":
        first_insert_string = "Enter book title: "
        second_insert_string = "Enter book author: "
    elif chosen_table == "movie":
        first_insert_string = "Enter movie title: "
        second_insert_string = "Enter movie director: "
    elif chosen_table == "cd":
        first_insert_string = "Enter CD title: "
        second_insert_string = "Enter CD artist: "
    elif chosen_table == "sheet music":
        first_insert_string = "Enter sheet music title: "
        second_insert_string = "Enter sheet music composer: "
    elif chosen_table == "comics":
        first_insert_string = "Enter comic title: "
        second_insert_string = "Enter comic illustrator: "

    # Get inputs.
    first_insert = input(first_insert_string)
    second_insert = input(second_insert_string)
    print()
    return id, first_insert, second_insert

# Get column names based on table
def getColumns(chosen_table):
    if chosen_table == "library":
        return "name", "location"
    elif chosen_table == "user":
        return "name", "email"
    elif chosen_table == "book":
        return "title", "author"
    elif chosen_table == "movie":
        return "title", "director"
    elif chosen_table == "cd":
        return "title", "artist"
    elif chosen_table == "sheet music":
        return "title", "composer"
    elif chosen_table == "comics":
        return "title", "illustrator"

# Insert data to sqlite database
def insertIntoSQLiteDatabase(sql_connection, chosen_table, id, first_insert, second_insert):
    cursor = sql_connection.cursor()

    column1, column2 = getColumns(chosen_table) # Get column names for the chosen table

    try:
        cursor.execute(f"INSERT INTO {chosen_table} (id, {column1}, {column2}) VALUES (?, ?, ?)", (id, first_insert, second_insert))
        sql_connection.commit()
    except sqlite3.Error as e:
        cprint(f"Error inserting into SQLite table '{chosen_table}': {e}", "red")
    return 0

# Insert MongoDB
def insertIntoMongoDB(mongo_db, chosen_table, id, first_insert, second_insert):
    column1, column2 = getColumns(chosen_table) # Get column names for the chosen table
    document = {"id": id, column1: first_insert, column2: second_insert}  # Create document to insert
    #Insert document into collection
    try:
        collection = mongo_db[chosen_table]
        collection.insert_one(document)
    except pymongo.errors.PyMongoError as e:
        cprint(f"Error inserting into MongoDB collection '{chosen_table}': {e}", "red")
    return 0

# Update from databases
def updateDatabase(sql_connection, mongo_db):
    chosen_table = readChoices() # Choose table to update

    if chosen_table is None:
        return
    
    # Show current data before updating
    readDatabase(sql_connection, mongo_db, chosen_table)

    # Get data to update
    id_to_update = input("Enter the ID of the record to update: ")
    new_first_value = input("Enter the new value for the first field: ")
    new_second_value = input("Enter the new value for the second field: ")

    # Here we try to update both databases, even when we know only one has the data. This is done to ease my workload.
    if chosen_table in SQL_TABLES:
        updateSQLiteDatabase(sql_connection, chosen_table, id_to_update, new_first_value, new_second_value)
    if chosen_table in NOSQL_TABLES:
        updateMongoDB(mongo_db, chosen_table, id_to_update, new_first_value, new_second_value)
    if chosen_table not in SQL_TABLES and chosen_table not in NOSQL_TABLES: # Should never get here.
        cprint(f"Table/collection '{chosen_table}' not found in either database.\n", "red")

    return 0

# Update sqlite
def updateSQLiteDatabase(sql_connection, chosen_table, id_to_update, new_first_value, new_second_value):
    cursor = sql_connection.cursor()
    column1, column2 = getColumns(chosen_table) # Get column names for the chosen table
    try:
        cursor.execute(f"UPDATE {chosen_table} SET {column1} = ?, {column2} = ? WHERE id = ?", (new_first_value, new_second_value, id_to_update))
        sql_connection.commit()
    except sqlite3.Error as e:
        cprint(f"Error updating SQLite table '{chosen_table}': {e}\n", "red")
    return 0

# Update MongoDB
def updateMongoDB(mongo_db, chosen_table, id_to_update, new_first_value, new_second_value):
    try:
        collection = mongo_db[chosen_table]
        column1, column2 = getColumns(chosen_table)
        collection.update_one({"id": int(id_to_update)}, {"$set": {column1: new_first_value, column2: new_second_value}})
        
    except pymongo.errors.PyMongoError as e:
        cprint(f"Error updating MongoDB collection '{chosen_table}': {e}\n", "red")
    return 0

# Delete from databases
def deleteFromDatabase(sql_connection, mongo_db):
    chosen_table = readChoices() # Choose table to delete from

    if chosen_table is None:
        return
    
    # Show current data before deleting
    readDatabase(sql_connection, mongo_db, chosen_table)
    id_to_delete = input("Enter the ID of the record to delete: ")

    # Here we try to delete from both databases, even when we know only one has the data. This is done to ease my workload.
    if chosen_table in SQL_TABLES:
        deleteFromSQLiteDatabase(sql_connection, chosen_table, id_to_delete)
    if chosen_table in NOSQL_TABLES:
        deleteFromMongoDB(mongo_db, chosen_table, id_to_delete)
    if chosen_table not in SQL_TABLES and chosen_table not in NOSQL_TABLES: # Should never get here.
        cprint(f"Table/collection '{chosen_table}' not found in either database.\n", "red")

    return 0

# Delete from sqlite
# Generated by CoPilot.
def deleteFromSQLiteDatabase(sql_connection, chosen_table, id_to_delete):
    cursor = sql_connection.cursor()
    try:
        cursor.execute(f"DELETE FROM {chosen_table} WHERE id = ?", (id_to_delete,))
        sql_connection.commit()
    except sqlite3.Error as e:
        cprint(f"Error deleting from SQLite table '{chosen_table}': {e}\n", "red")
    return 0

# Delete from MongoDB
# Generated by CoPilot.
def deleteFromMongoDB(mongo_db, chosen_table, id_to_delete):
    try:
        collection = mongo_db[chosen_table]
        collection.delete_one({"id": int(id_to_delete)})
        
    except pymongo.errors.PyMongoError as e:
        cprint(f"Error deleting from MongoDB collection '{chosen_table}': {e}\n", "red")
    return 0

# Create databases if they don't already exist.
def createSQLDatabase():
    # Check if schema file exists
    if not os.path.exists(SQL_CREATION_FILE):
        cprint(f"Schema file for SQL-database does not exist. Cannot create database.", "red")
        exit()
    
    try: 
        cprint("Connecting to SQLite database...", "yellow")
        if not os.path.exists(SQL_DATABASE_FILE):   # If database file does not exist, create it.
            with open(SQL_CREATION_FILE, 'r', encoding='utf-8') as file:
                schema_sql = file.read()

            conn = sqlite3.connect(SQL_DATABASE_FILE)
            cursor = conn.cursor()
            cursor.executescript(schema_sql)
            conn.commit()
            cprint(f"Created database {SQL_DATABASE_FILE} successfully.", "green")
        else:   # If database file exists, just connect to it.
            cprint(f'{SQL_DATABASE_FILE} already exists.', "yellow")
            restoreSQLDatabase()
            conn = sqlite3.connect(SQL_DATABASE_FILE)

    except Exception as e:
        cprint(f"Error creating database {SQL_DATABASE_FILE}: {e}", "red")
        cprint("Closing application.", "red")
        exit()

    cprint("Connected to SQLite database successfully.\n", "green")
    return conn

def createNoSQLDatabase():
    cprint("Connecting to MongoDB database...", "yellow")
    try:
        client = pymongo.MongoClient(URI, serverSelectionTimeoutMS=5000)
        # verify connection
        client.admin.command("ping")
    except pymongo.errors.PyMongoError as e:
        cprint(f"Could not connect to MongoDB at {URI}: {e}", "red")
        return None, None

    mongo_db = client[DB_NAME]

    # Ensure all expected NoSQL collections exist (use NOSQL_TABLES so we don't miss any)
    existing = mongo_db.list_collection_names()
    for collection in NOSQL_TABLES:
        if collection not in existing:
            try:
                mongo_db.create_collection(collection)
            except pymongo.errors.CollectionInvalid:
                pass

    populate_mongo_from_seed(SEED_FILE, client, DB_NAME)
    cprint("Connected to MongoDB database successfully.\n", "green")
    return client, mongo_db

# Restore databases to their original state
def restoreNoSQLDatabase(mongo_client):
    
    try:
        mongo_client.drop_database(DB_NAME)
        populate_mongo_from_seed(SEED_FILE, mongo_client, DB_NAME)
        cprint(f"Restored database {DB_NAME} successfully.\n", "green")
    except Exception as e:
        cprint(f"Could not restore database {DB_NAME}: {e}", "red")

    return 0

# Restore SQL database from creation file
def restoreSQLDatabase():
    try:
        if os.path.exists(SQL_DATABASE_FILE):
            cprint(f"Deleting database {SQL_DATABASE_FILE}...", "yellow")
            os.remove(SQL_DATABASE_FILE)
            cprint(f"Deleted database {SQL_DATABASE_FILE} successfully.", "green")
            createSQLDatabase()
    except Exception:
        cprint(f"Error deleting database {SQL_DATABASE_FILE}.", "red")

    return 0

# This function has been generated by CoPilot.
def populate_mongo_from_seed(seed_path, mongo_client, DB_NAME="DIS_database"):
    """
    Read JSON seed file and populate MongoDB collections.
    Drops each target collection before inserting to avoid duplicates.
    """
    try:
        with open(seed_path, "r", encoding="utf-8") as f:
            seed = json.load(f)
    except Exception as e:
        cprint(f"Cannot read seed file {seed_path}: {e}", "red")
        return False

    db = mongo_client[DB_NAME]
    for coll_name, docs in seed.items():
        try:
            db.drop_collection(coll_name)
        except Exception:
            pass
        if docs:
            try:
                # insert_many expects dicts; keep ids as-is
                db[coll_name].insert_many(docs)
            except Exception as e:
                cprint(f"Error inserting into {coll_name}: {e}", "red")
                return False
    return True

if __name__ == "__main__":
    main()
