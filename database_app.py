# This code has been written by Otto Oikarinen.
# Some parts have been generated by CoPilot. I'll mark those parts specifically.

# Imports
import os
import sqlite3
import pymongo
import json

# Global variables
SQL_DATABASE_FILE = "SQL_database.db"
SQL_CREATION_FILE = "create_SQL_DB.sql"
DB_NAME="DIS_database"
SEED_FILE="mongo_seed.json"
URI="mongodb://localhost:27017/"
HIGHEST_ID = 100

# Data tables
ALL_TABLES = ["library", "user", "book", "movie", "cd", "sheet music", "comics"]
SQL_TABLES = ["library", "user", "book", "movie", "cd"]
NOSQL_TABLES = ["library", "user", "book", "sheet music", "comics"]

# Main function to call all other functions.
def main():
    sql_connection = createSQLDatabase() # First create databases or restore them to original state.
    mongo_client, mongo_db = createNoSQLDatabase()

    while True:
        
        print("What do you want to do?")
        print("1) Read from database")
        print("2) Update database")
        print("3) Delete from database")
        print("4) Insert into database")
        print("5) Restore databases to original state")
        print("0) Exit")
        choice = input("Enter the number of your choice: ")
        if choice == '1':
            print("Reading from database.")
            readDatabase(sql_connection, mongo_db)  
        elif choice == '2':
            print("Updating database.")
            #updateDatabase(connection)
        elif choice == '3':
            print("Deleting from database")
            #deleteFromDatabase(connection)
        elif choice == '4':
            print("Inserting into database.")
            insertIntoDatabase(sql_connection, mongo_db)
        elif choice == '5':
            print("Restoring databases to original state.")
            restoreDatabases(mongo_client)
        elif choice == '0':
            print("Exiting program.")
            exit()
        else:
            print("Invalid choice. Please try again.")

    return 0

# Main choices


# Read choices
def readChoices():
    print("Which data do you want to read?")
    # Create menu automatically from ALL_TABLES
    for i, table in enumerate(ALL_TABLES, start=1):
        print(f"{i}) {table}")
    print("0) Go back")
    choice = input("Enter the number of your choice: ")

    # If 0, we go back to main menu
    if choice == '0':
        return None
    
    # Validate choice and handle errors.
    try:
        choice = int(choice)
        if 1 <= choice <= len(ALL_TABLES):
            return ALL_TABLES[choice - 1]
        else:
            print("Invalid choice. Please try again.")
            return readChoices()
    except ValueError:
        print("Invalid input. Please enter a number.")
        return readChoices()

# Read sqlite-database
def readDatabase(sql_connection, mongo_db):
    chosen_table = readChoices()
    if chosen_table is None:
        return
    if chosen_table in SQL_TABLES:
        readSQLiteDatabase(sql_connection, chosen_table)
    if chosen_table in NOSQL_TABLES:
        readMongoDatabase(mongo_db, chosen_table)
    if chosen_table not in SQL_TABLES and chosen_table not in NOSQL_TABLES:
        print(f"Table/collection '{chosen_table}' not found in either database.")

    return 0

def readSQLiteDatabase(sql_connection, chosen_table):
    cursor = sql_connection.cursor()
    try:
        print(f"Reading from SQLite table '{chosen_table}':")
        cursor.execute(f"SELECT * FROM {chosen_table}")
        rows = cursor.fetchall()
            
        for row in rows:
            print(f"{row[0]}, {row[1]}, {row[2]}")
    except sqlite3.Error as e:
        print(f"Error reading from SQLite table '{chosen_table}': {e}")
    return 0

# Read MongoDB-database
def readMongoDatabase(mongo_db, chosen_table):
    try:
        print(f"Reading from MongoDB collection '{chosen_table}':")
        collection = mongo_db[chosen_table]
        documents = collection.find()
        for doc in documents:
            # Following snippet coded by CoPilot.
            # Preserve insertion order, ignore MongoDB internal _id
            values = [v for k, v in doc.items() if k != "_id"]
            # Ensure at least three columns to match "id, name, location" style
            while len(values) < 3:
                values.append("")
            # Convert values to strings for consistent printing
            a, b, c = map(lambda x: "" if x is None else str(x), values[:3])
            print(f"{a}, {b}, {c}")

    except pymongo.errors.PyMongoError as e:
        print(f"Error reading from MongoDB collection '{chosen_table}': {e}")
    return 0

# Insert choices


# Insert into database
def insertIntoDatabase(sql_connection, mongo_db):
    chosen_table = readChoices()
    if chosen_table is None:
        return

    # Gather data to insert
    try:
        id = int(input("Enter id (number): "))
        name = input("Enter name: ")
        location = input("Enter location: ")
    except ValueError:
        print("Invalid input. ID must be an integer.")
        return

    if chosen_table in SQL_TABLES:
        insertIntoSQLiteDatabase(sql_connection, chosen_table, id, name, location)
    elif chosen_table in NOSQL_TABLES:
        insertIntoMongoDB(mongo_db, chosen_table, id, name, location)
    else:
        print(f"Table/collection '{chosen_table}' not found in either database.")

    return 0

# Insert sqlite
def insertIntoSQLiteDatabase(sql_connection, chosen_table, id, name, location):
    cursor = sql_connection.cursor()
    try:
        cursor.execute(f"INSERT INTO {chosen_table} (id, name, location) VALUES (?, ?, ?)", (id, name, location))
        sql_connection.commit()
        print(f"Inserted into SQLite table '{chosen_table}': {id}, {name}, {location}")
    except sqlite3.Error as e:
        print(f"Error inserting into SQLite table '{chosen_table}': {e}")
    return 0

# Insert MongoDB
def insertIntoMongoDB(mongo_db, chosen_table, id, name, location):
    if chosen_table == "sheet music":
        document = {"id": id, "title": name, "composer": location}
    elif chosen_table == "comics":
        document = {"id": id, "title": name, "illustrator": location}

    #Insert document into collection
    try:
        collection = mongo_db[chosen_table]
        collection.insert_one(document)
        print(f"Inserted into MongoDB collection '{chosen_table}': {document}")
    except pymongo.errors.PyMongoError as e:
        print(f"Error inserting into MongoDB collection '{chosen_table}': {e}")
    return 0

# Update choices


# Update from databases


# Update sqlite


# Update MongoDB


# Delete choices


# Delete from databases


# Delete from sqlite


# Delete from MongoDB


# Create databases if they don't already exist.
def createSQLDatabase():
    
    if not os.path.exists(SQL_CREATION_FILE):
        print(f"Schema file for SQL-database does not exist. Cannot create database.")
        exit()
    
    try: 
        print("Connecting to SQLite database...")
        if not os.path.exists(SQL_DATABASE_FILE):
            with open(SQL_CREATION_FILE, 'r', encoding='utf-8') as file:
                schema_sql = file.read()

            conn = sqlite3.connect(SQL_DATABASE_FILE)
            cursor = conn.cursor()
            cursor.executescript(schema_sql)
            conn.commit()
            print(f"Created database {SQL_DATABASE_FILE} successfully.")
        else:
            print(f'{SQL_DATABASE_FILE} already exists.')
            conn = sqlite3.connect(SQL_DATABASE_FILE)

    except Exception as e:
        print(f"Error creating database {SQL_DATABASE_FILE}: {e}")
        print("Closing application.")
        exit()

    print("Connected to SQLite database successfully.")
    return conn

def createNoSQLDatabase():
    print("Connecting to MongoDB database...")
    try:
        client = pymongo.MongoClient(URI, serverSelectionTimeoutMS=5000)
        # verify connection
        client.admin.command("ping")
    except pymongo.errors.PyMongoError as e:
        print(f"Could not connect to MongoDB at {URI}: {e}")
        return None, None

    mongo_db = client[DB_NAME]

    # Ensure all expected NoSQL collections exist (use NOSQL_TABLES so we don't miss any)
    existing = mongo_db.list_collection_names()
    for collection in NOSQL_TABLES:
        if collection not in existing:
            try:
                mongo_db.create_collection(collection)
            except pymongo.errors.CollectionInvalid:
                pass

    populate_mongo_from_seed(SEED_FILE, client, DB_NAME)
    print("Connected to MongoDB database successfully.")
    return client, mongo_db

# Restore databases to their original state
def restoreDatabases(mongo_client):
    
    try:
        if os.path.exists(SQL_DATABASE_FILE):
            os.remove(SQL_DATABASE_FILE)
            print(f"Deleted database {SQL_DATABASE_FILE} successfully.")
            createSQLDatabase()
    except Exception:
        print(f"Error deleting database {SQL_DATABASE_FILE}.")
    
    try:
        mongo_client.drop_database(DB_NAME)
        populate_mongo_from_seed(SEED_FILE, mongo_client, DB_NAME)
        print(f"Restored database {DB_NAME} successfully.")
    except Exception as e:
        print(f"Could not restore database {DB_NAME}: {e}")

    return 0

# This function has been generated by CoPilot.
def populate_mongo_from_seed(seed_path, mongo_client, DB_NAME="DIS_database"):
    """
    Read JSON seed file and populate MongoDB collections.
    Drops each target collection before inserting to avoid duplicates.
    """
    try:
        with open(seed_path, "r", encoding="utf-8") as f:
            seed = json.load(f)
    except Exception as e:
        print(f"Cannot read seed file {seed_path}: {e}")
        return False

    db = mongo_client[DB_NAME]
    for coll_name, docs in seed.items():
        try:
            db.drop_collection(coll_name)
        except Exception:
            pass
        if docs:
            try:
                # insert_many expects dicts; keep ids as-is
                db[coll_name].insert_many(docs)
            except Exception as e:
                print(f"Error inserting into {coll_name}: {e}")
                return False
    return True

if __name__ == "__main__":
    main()
